package 代码随想录一刷.回溯;

public class summary {
    /**  回溯法其实就是以递归的方式来是实现循环，本质上是一种暴力算法
     一般是由for循环和递归组成
     可以参考递归的思路
     三步走：返回值和参数，终止条件，单层逻辑
     对于只需要找到一条路径的题，返回值是boolean，其它一般是void
     将最终的返回结果集定义为全局变量或者参数都行

     回溯算法能解决的问题：
     组合问题：N个数里面按一定规则找出k个数的集合
     排列问题：N个数按一定规则全排列，有几种排列方式
     切割问题：一个字符串按一定规则有几种切割方式
     子集问题：一个N个数的集合里有多少符合条件的子集
     棋盘问题：N皇后，解数独等等

     回溯法代码中回溯方法的模板
     void backtracking(参数) {
     if (终止条件) {
     存放结果;
     return;
     }
     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
     处理节点;
     backtracking(路径，选择列表); // 递归
     代码随想录.二叉树.回溯，撤销处理结果
     }
     }
     对于一道题来说，一定会有某个数组，字符串之类的东西是需要遍历的，它用for来遍历
     而递归用来遍历每一种可能的结果，因为仅仅是可能的结果，所以是需要回溯的
     两者结合遍历所有情况后，收集满足条件的解（一般是在叶子节点上）
     可以用回溯法的题一定可以抽象为树形结构，树的宽度是for，高度是递归

     还可以注意的是解集中是否可以重复的元素，以及用uesd数组（哈希表法）和set去重的方法
     还有将startIndex作为参数传入递归函数中，这样就可以避免重复的遍历
     */
}